------



# 一 Java基础题

> 作者：小白。
>
> **介绍:** 常见面试题

## 1 请你说说Java的特点和优点，为什么要选择Java？

Java是一种**面向对象**的编程语言。

Java吸收了C++语言的优点同时，去除了多继承、指针等难以理解的概念，**比C++语言更为简单易用**。

Java可以**跨平台**，“一次编译，到处运行”。

Java提供很多**内置类库**，简化了开发。

Java提供了**垃圾回收器**，开发人员从内存管理中解脱。

Java**安全健壮**，eg强类型机制、垃圾回收器、异常处理和安全检查机制都是保障。

Java支持web应用开发。

### 为什么可以跨平台？

**JVM**是Java跨平台的关键。在运行程序之前，Java源代码经过编译器将**源代码**(.Java)翻译成**字节码**(.class)，字节码不能直接运行，必须通过JVM将字节码翻译成**特定平台的机器运行程序**。跨平台的是Java程序，而不是JVM，不同平台安装不同版本的JVM。

## 2 请你说说Java基本数据类型和引用类型

Java的数据类型分为基本数据类型和引用数据类型两大类。 

基本数据类型：byte(8), short(16), int(32), long(64), float(32), double(64), char(16), boolean。

引用类型：类、接口、数组、特殊的null类型。引用类型变量存储的是内存地址。

## 3 请你说一下抽象类和接口的区别

抽象类：abstract关键字修饰的类叫抽象类，abstract修饰的方法被称为抽象方法

接口：interface关键字修饰

相同点：**都不能被实例化**，接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法才能被实例化。

不同点：

**方法**：接口里只能提供抽象方法和默认方法，不能为普通方法提供方法实现，抽象类则可以包括普通方法。

**变量**：接口只能定义静态常量，不能定义普通成员变量。抽象类里既可以定义静态常量，也可以定义普通成员变量。

**构造器**：接口里不包括构造器，抽象类里可以包括构造器，但不是用于创造对象，而是供子类调用完成属于抽象类的初始化操作。

**初始化块**：接口里不包含初始化块，抽象类则可以包括。

**单继承**：一个类最多只有一个父类，包括抽象类，但一个类可以实现多个接口，通过实现多个接口可以弥补java单继承的不足。

在二者的**设计目的**上，接口作为系统与外界交互的窗口，体现了一种规范，对于接口的实现者来说，接口规定了实现者必须向外提供哪些服务，对于接口的调用者来说，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。当在多个应用程序间使用接口时，接口是多个程序之间的通信标准。抽象类则不一样，抽象类作为多个子类的父类，它可以被当作系统实现过程的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当作最终产品，必须要有更进一步的完善，这种完善可能有几种不同方式。

## 4 请你说一下final关键字

final关键字可以用来标识其修饰的类、方法、变量不可变。

**修饰类**代表类不可以被继承，eg Java.Lang.Math就是一个final类，不能被继承。

**修饰方法**代表方法不可以被重写。

**修饰变量**代表变量不可被改变，即一旦获得了初始值，就不能被重新赋值。

具体来说：对于final修饰的成员变量来讲，一旦有了初始值就不能被重新赋值。如果既没有在定义成员变量时赋初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这个成员变量就将一直是系统默认分配的值，那么这个成员变量就失去了意义。所以java规定：final修饰的成员变量必须由程序员显示的指定初始值，final修饰的实例变量，要么在定义该实例变量时指定初始值，要么在普通初始化块或构造器中为该实例变量指定初始值。但要注意的是，如果普通初始化块已经为这个实例变量指定了初始值，则不能在构造器中为该实例变量指定初始值。final修饰的类变量，要么在定义该变量时指定初始值，要么在静态初始化块中为该变量指定初始值。实例变量不能在静态初始化块里指定初始值，因为静态初始化块是静态成员，不可以访问实例变量。类变量不能在普通初始化块中指定初始值，因为类变量在类初始化阶段已经被初始化，普通的初始化块不能为其重新赋值。系统不会为局部变量进行初始化，所以局部变量必须由程序员显示的初始化。因此使用final修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值。如果final修饰的局部变量在定义时没有指定默认值，则可以在后面的代码中对该final变量赋初始值，但只能一次，不能重复赋值。如果final修饰的局部变量在定义时已经指定默认值，则后面的代码中不能再对该变量赋值。

## 5 说说static修饰符的用法

static修饰变量：属于静态变量也叫类变量，直属于类对象而不是实例，可以通过类名访问，它一般会在类加	载过程中被初始化，生命周期贯穿整个程序，存储在方法区中。

static修饰方法：即静态方法，一个类中的静态方法不能访问该类的实例变量，只能访问静态变量。

static修饰代码块：即静态初始化块，他在类加载过程中被调用用于对该类中的静态变量进行操作。

static修饰类：即静态内部类，他只能以内部类的形式存在，可通过外部类的类名调用，但是它也只能访问到外部的的静态成员。

## 6 请你说说String类，以及创建字符串的方法

String类是java常用api，处理字符串的工具类。含charAt，subString，split，indexOf，startsWith，endWith，replace等常用方法，

创建字符串有两种方法，一是使用**字符串直接量**，第二个就是**new关键字**。 当使用字符串直接量时，jvm会使用常量池管理这个字符串，当使用new关键字时，会开辟出一个堆内存来保存这个新创建出的String对象，不建议。

## 7 String、StringBuffer、StringBuilder有什么区别

String不可变类。

StringBuffer、StringBuilder都可变，常用append、toString等方法来操作字符串。

StringBuilder没有考虑线程安全性，性能比StringBuffer略高。

## 8 请你说说==与equals()的区别

==既可以比较基本类型也可以比较引用类型，基本类型比较的是值，引用类型比较的是地址。

equals是Object的方法，比较的是引用类型，如果equals没有被重写，和==是一样的，比较地址，如果被重写，具体情况具体分析。例如String，比较的是值。

## 9 请你说说hashCode()和equals()的区别，为什么重写equals()就要重写hashCode()

hashCode():获取哈希值，equals():比较两个对象是否相等。

二者之间有两个约定：两个对象equals相等，则hash值一定相等，hash值相等两个对象不一定相等。

为了确保如上约定，重写equals就一定要重写hashCode。

## 10 请你讲一下Java8的新特性

**Lambda表达式**：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。

*方法引用**：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。

**默认方法**：默认方法就是一个在接口里面有了一个实现的方法。

**新工具**：新的编译工具，eg Nashorn引擎jjs、类依赖分析器jdeps。

**Stream API**：新添加的Stream API（java.util.stream），把真正的函数式编程风格引入到Java中。

**Date Time API**：加强对日期与时间的处理。

**Optional类**：Optional 类已经成为Java 8类库的一部分，用来解决空指针异常。

**Nashorn, JavaScript引擎**：Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。
