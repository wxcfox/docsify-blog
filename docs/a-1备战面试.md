------



# 一 备战面试

> 作者：小白。
>
> **介绍:** xxx

hello

## 1.1 进程、线程、协程

### 1.1.1 进程、线程、协程关系

进程与线程：

进程是应用程序的执行副本，进程是资源管理的单位，进程要管理硬件资源、CPU资源、文件资源、内存分页等，执行只需要CPU和内存。进程来回切换消耗资源且多进程之间的共享通信会更加复杂，所以抽象出一个更小的单位线程。当一个程序启动以后（进程），会产生一个主线程，操作系统将计算资源不给进程，而是直接给主线程。线程是程序执行的单位，每个线程执行时都有一个时间片，当时间片执行完了以后，切换下一个线程执行。但是操作系统调度的是自己的线程，自己的线程表，程序员在用户空间创建线程，但是真正执行的是操作系统的线程，操作系统的线程和用户线程是映射关系。也就是说，操作系统的线程才是真正的线程，程序员并不能直接执行直接的线程，必须要挂靠到操作系统的线程执行。

线程池：高并发的场景下，会有很多task，为每个task创建一个线程（线程对象）很占用内存空间，每个线程都对应一个操作系统的线程（内核线程），这样操作系统忙不过来。所以设计了线程池技术，溢出线程池怎么办，让task排队（线程会回收到线程池）。

线程与协程：

在 Go 语言中，协程被认为是轻量级的线程。但是和线程不同的是，操作系统内核感知不到协程的存在。协程的管理，依赖 Go 语言运行时自身提供的调度器（scheduler）。同时，Go 中的协程是从属于某一个线程的，协程与线程是多对多的关系。Go 调度器可以将多个协程分配到一个线程中，一个协程也可能会转移到多个线程中执行。

上下文切换的速度：协程要快于线程，因为协程的切换不用经过操作系统用户态与内核态的切换，并且 Go 语言中协程的切换只需要保留极少的状态和寄存器变量值（SP/BP/PC），而线程的切换会保留额外的寄存器变量值（例如浮点寄存器）。在 Go 语言中，上下文切换速度的一个可参考量化指标是，线程大约为 1~2 微秒，协程大约是 0.2 微秒，比线程快数倍。

调度策略：线程的调度基本上是抢占式的，操作系统调度器为了均衡每一个线程的执行周期，会定时发出中断信号强制执行线程上下文切换。而协程一般情况下是协作式调度的。当一个协程处理完自己的任务后，可以主动将执行权限让给其他协程。这意味着协程能更好地在规定时间内完成自己的工作，而不会被任意抢占。当一个协作式运行的时间过长，Go 语言调度器才会强制抢占其执行。

栈的大小：线程的栈大小一般是在创建时指定，为了避免出现栈溢出（Stack Overflow）的错误，默认的栈大小会相对较大（例如 2M），这意味着创建 1000 个线程就需要消耗 2G 的虚拟内存，这大大限制了线程创建的数量。而 Go 语言中的协程栈默认为 2KB，在实践中，我们经常会看成千上万的协程存在。另外，线程的栈在运行时不能够更改，而协程栈在 Go 运行时的帮助下可以动态检测栈的大小，进行扩容和收缩。由于协程栈很小，在实践中，协程常被看作是一种轻量级的资源。

总结：协程的运行依托于操作系统对于线程的调度执行，而线程的执行离不开操作系统对于进程的管理。

<img src="pictures/进程、线程、协程.png" width="200" height="200"/>

参考： https://www.codeplayer.org/Wiki/Others/geekbang/线程与进程、协程的区别到底在哪？.html

### 1.1.2 进程间通信方式

a. 管道模型（匿名管道、命名管道）：

管道：管道实质是内核中的一块内存缓存区。创建缓存后会返回两个文件描述符，分别是读与写。有名管道可以在不存在亲缘关系的进程中通信。管道的缺点：只能FIFO、数据无格式且大小受限、并且通信方式是单向的，若需要双向则需要建立两个通道。

b. 消息队列模型

消息队列：消息队列是内核中的消息链，消息队列支持消息的随机查询，且能够实现多个进程间的读写操作。消息队列相比管道能承载更多的消息。但是消息队列与管道一样，都存在内核与用户内存间的数据拷贝，因此不适合进行频繁的通信。消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。

c. 共享内存+信号量

共享内存：两个进程拿出一块虚拟地址空间来，映射到相同的物理内存中，共享内存不再需要用户到内核的数据拷贝，通信双方直接操作用户空间的共享内存即可完成通信。
信号量：为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：
一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。
信号初始化为 1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。
信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。

<img src="pictures/互斥信号量.png" width="200" height="200"/>
<img src="pictures/同步信号量.png" width="200" height="200"/>

d. 信号

信号：是事件发生对进程的通知机制，它是软件层次上对中断机制的一种模式，是进程间通信机制中唯一的异步通信机制。对于异常情况下的工作模式，就需要用信号的方式来通知进程。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）
因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式：
执行默认操作：Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。
捕捉信号：我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。
忽略信号：当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。

e. socket

socket：前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

参考： https://www.cnblogs.com/xiaolincoding/p/13402297.html
