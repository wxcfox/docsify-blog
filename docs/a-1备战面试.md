------



# 一 备战面试

> 作者：小白。
>
> **介绍:** 面试常见知识点专题

## 1.1 进程、线程、协程

### 1.1.1 进程、线程、协程关系

进程与线程：

进程是应用程序的执行副本，进程是资源管理的单位，进程要管理硬件资源、CPU资源、文件资源、内存分页等，执行只需要CPU和内存。进程来回切换消耗资源且多进程之间的共享通信会更加复杂，所以抽象出一个更小的单位线程。当一个程序启动以后（进程），会产生一个主线程，操作系统将计算资源不给进程，而是直接给主线程。线程是程序执行的单位，每个线程执行时都有一个时间片，当时间片执行完了以后，切换下一个线程执行。但是操作系统调度的是自己的线程，自己的线程表，程序员在用户空间创建线程，但是真正执行的是操作系统的线程，操作系统的线程和用户线程是映射关系。也就是说，操作系统的线程才是真正的线程，程序员并不能直接执行直接的线程，必须要挂靠到操作系统的线程执行。

线程池：高并发的场景下，会有很多task，为每个task创建一个线程（线程对象）很占用内存空间，每个线程都对应一个操作系统的线程（内核线程），这样操作系统忙不过来。所以设计了线程池技术，溢出线程池怎么办，让task排队（线程会回收到线程池）。

线程与协程：

在 Go 语言中，协程被认为是轻量级的线程。但是和线程不同的是，操作系统内核感知不到协程的存在。协程的管理，依赖 Go 语言运行时自身提供的调度器（scheduler）。同时，Go 中的协程是从属于某一个线程的，协程与线程是多对多的关系。Go 调度器可以将多个协程分配到一个线程中，一个协程也可能会转移到多个线程中执行。

上下文切换的速度：协程要快于线程，因为协程的切换不用经过操作系统用户态与内核态的切换，并且 Go 语言中协程的切换只需要保留极少的状态和寄存器变量值（SP/BP/PC），而线程的切换会保留额外的寄存器变量值（例如浮点寄存器）。在 Go 语言中，上下文切换速度的一个可参考量化指标是，线程大约为 1~2 微秒，协程大约是 0.2 微秒，比线程快数倍。

调度策略：线程的调度基本上是抢占式的，操作系统调度器为了均衡每一个线程的执行周期，会定时发出中断信号强制执行线程上下文切换。而协程一般情况下是协作式调度的。当一个协程处理完自己的任务后，可以主动将执行权限让给其他协程。这意味着协程能更好地在规定时间内完成自己的工作，而不会被任意抢占。当一个协作式运行的时间过长，Go 语言调度器才会强制抢占其执行。

栈的大小：线程的栈大小一般是在创建时指定，为了避免出现栈溢出（Stack Overflow）的错误，默认的栈大小会相对较大（例如 2M），这意味着创建 1000 个线程就需要消耗 2G 的虚拟内存，这大大限制了线程创建的数量。而 Go 语言中的协程栈默认为 2KB，在实践中，我们经常会看成千上万的协程存在。另外，线程的栈在运行时不能够更改，而协程栈在 Go 运行时的帮助下可以动态检测栈的大小，进行扩容和收缩。由于协程栈很小，在实践中，协程常被看作是一种轻量级的资源。

总结：协程的运行依托于操作系统对于线程的调度执行，而线程的执行离不开操作系统对于进程的管理。

<img src="pictures/进程、线程、协程.png" width="600"/>

参考： https://www.codeplayer.org/Wiki/Others/geekbang/线程与进程、协程的区别到底在哪？.html

### 1.1.2 进程间通信方式

a. 管道模型（匿名管道、命名管道）：

管道：管道实质是内核中的一块内存缓存区。创建缓存后会返回两个文件描述符，分别是读与写。有名管道可以在不存在亲缘关系的进程中通信。管道的缺点：只能FIFO、数据无格式且大小受限、并且通信方式是单向的，若需要双向则需要建立两个通道。

b. 消息队列模型

消息队列：消息队列是内核中的消息链，消息队列支持消息的随机查询，且能够实现多个进程间的读写操作。消息队列相比管道能承载更多的消息。但是消息队列与管道一样，都存在内核与用户内存间的数据拷贝，因此不适合进行频繁的通信。消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。

c. 共享内存+信号量

共享内存：两个进程拿出一块虚拟地址空间来，映射到相同的物理内存中，共享内存不再需要用户到内核的数据拷贝，通信双方直接操作用户空间的共享内存即可完成通信。
信号量：为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：
一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。
信号初始化为 1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。
信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。

<img src="pictures/互斥信号量.png" width="200" height="200"/>
<img src="pictures/同步信号量.png" width="200" height="200"/>

d. 信号

信号：是事件发生对进程的通知机制，它是软件层次上对中断机制的一种模式，是进程间通信机制中唯一的异步通信机制。对于异常情况下的工作模式，就需要用信号的方式来通知进程。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）
因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式：
执行默认操作：Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。
捕捉信号：我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。
忽略信号：当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。

e. socket

socket：前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

参考： https://www.cnblogs.com/xiaolincoding/p/13402297.html

## 1.2 Mysql

### 1.2.1 B树、B+树

B树和B+树都是平衡多路查找树，都是在二叉树的基础上改进的数据结构。二叉树上查找数据，最坏的情况是查找次数为树的深度，数据量很大时，查询次数很大，造成大量磁盘io，影响查询效率。为了减少磁盘io的次数，必须降低树的深度，所以在二叉树的基础上将树改成了多叉并加上一些限制条件，就形成了B树，B+树是B树的变种。
B树、B+树区别：

B树中所有节点都存放数据，B+树只有叶子节点存放数据
B树中的叶子节点是独立的，B+树的叶子节点通过链与相邻叶子节点连接。
B树查找使用二分查找，没有查找到叶子节点就可能结束，B+树必须从根节点进行查找，查询效率更稳定。

### 1.2.2 索引怎么实现的B+树，为什么选这个数据结构

索引本质上是通过预排序+树形结构来加快检索效率，Mysql中使用InnoDB和MyISAM引擎时都使用B+树来实现索引。

B+树是一颗平衡多路查找树，是在二叉树的基础上改进的数据结构。二叉树查找数据时，最坏情况下查找次数为树的深度，当数据量很大时，会发生大量磁盘io，影响查询效率。为了减少磁盘io，就在二叉树的基础上改成了多叉并且加了限制条件形成B树，B+树又属于B树的变种。在B+树上，数据集合仅保留在叶子节点上，叶子节点间是个链的结构，从而可以支持快速范围查询，B+树上所有记录节点都是按照键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行链接。数据库中的B+树一般限制高度在2～4层，故io次数能稳定在2～4次。

数据库中的索引分为聚簇索引和非聚簇索引，聚簇索引一般用主键充当，叶子节点保存的是完整的一行记录，非聚簇索引保存的是非聚簇索引和其记录对应的聚簇索引，当通过非聚簇索引查找到相应数据的时候，最终还是需要通过叶子节点的聚簇索引拿到完整数据。

## 1.3 框架技术

### 1.3.1 对MVC的理解

MVC是一种模式，但却在GoF总结出来的这个23个设计模式之外，确切的说它不是一种设计模式，它是多种设计模式的组合，并不仅仅只是一个单独的一个模式。组成MVC的三个模式分别是组合模式、策咯模式、观察者模式，MVC在软件开发中发挥的威力，最终离不开这三个模式的默契配合。

**View层，单独实现了组合模式**

**View层和Model层，实现了观察者模式**

**View层和Controller层，实现了策咯模式**

MVC要实现的**目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强**。在这种模式下软件被分为三层，model、view、Controller。将软件分层的好处是可以将对象之间的耦合度降低，便于代码的维护。model封装了数据和对数据的操作，是实际进行数据处理的地方，view负责进行模型的展示，一般就是我们见到的用户界面，Controller控制器负责视图和模型之间的交互主要负责两方面的动作，一是把用户的请求分发到相应的模型，二是把模型的改变及时地响应到视图上。

Spring mvc是一个基于java的实现了mvc设计模式的轻量级web框架，Spring mvc框架已经成为了mvc模式的最主流实现，前端控制器是DispatcherServlet接口实现类，映射处理器是HandlerMapping接口实现类，视图解析器是ViewResolver接口实现类，页面控制器是Controller接口实现类。

参考： https://zhuanlan.zhihu.com/p/35680070
