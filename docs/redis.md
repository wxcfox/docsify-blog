## Redis基础

- Redis是基于键值对的NoSql数据库，支持string、hash、list、set、zset、geo、pubscribe、stream等各种数据结构。
- redis将数据放到内存中，读写性能块，有持久化机制。
- 场景丰富：缓存、数据库、限时任务、排行榜、分布式锁、分页查询等。

### Redis VS Memcached

共同点：

- 都是基于内存的数据库，一般都用来做缓存。
- 都有过期策略。
- 性能都很高。

不同点：

- Redis数据类型更丰富。Memcached只支持简单的kv数据类型。
- Redis支持数据的持久化。可以将内存中的数据保存在磁盘中，重启后可以再次加载使用，有灾难恢复机制。内存用完之后也可以将不用的数据保存在磁盘中。Memcached把数据全部存在内容中，会在服务器内存用完之后会报错。
- Redis原生支持cluster集群，Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
- Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）
- Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 还支持更多的编程语言。
- Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

## Redis应用

- 缓存
- 分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。
- 限流：一般是通过Redis + Lua 脚本的方式来实现限流。
- 消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK
  机制。
- 其他：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，很方便地完成很多复杂的业务场景。比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。

### 为什么用Redis做缓存

- 高性能

操作缓存就是直接操作内存，速度快。

- 高并发

单机Redis一般大概能支持数十万qps，Redis集群则更高。

- 高可用

数据持久化、主从数据同步、哨兵模式、Redis集群

## Redis数据结构

- string：string可以存储字符串、数字和二进制数据，string最大可以存储大小2M的数据。
- hash：编码分为ziplist、hashtable两种，ziplist底层实现为压缩列表，hashtable底层实现为字典。
- list：编码分别为ziplist（压缩列表）、linkedlist（双端链表）和quicklist。
- set：编码分为inset和hashset。
- zset：编码分为ziplist和skiplist。

### zset结构底层实现

zset 类型的底层数据结构是由ziplist压缩列表或skiplist跳表实现的：

- 如果有序集合的元素个数小于128个，并且每个元素的值小于64字节时，Redis会使用***ziplist***压缩列表作为zset类型的底层数据结构。
- 如果有序集合的元素不满足上面的条件，Redis会使用***skiplist***跳表作为zset类型的底层数据结构。

## Redis持久化机制

### RDB 持久化

Redis 默认采用的持久化方式，Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis
主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

### AOF 持久化

与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了）。

## Redis线程模型

### Redis单线程模型

Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。

- 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis
内部单线程设计的简单性。

### Redis单线程模型为什么还这么快

- Redis 的大部分操作都在***内存***中完成，并且采用了***高效的数据结构***，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以避免了多线程之间的竞争，省去了***多线程切换***带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了***I/O 多路复用机制***处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis
  只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis
  线程处理多个 IO 流的效果。

### Redis 6.0 之后为什么引入多线程

Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

## Redis内存管理

### 过期数据的删除策略

- 惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
- 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。Redis 采用的是 定期删除+惰性 删除。

## Redis生产问题

- 缓存穿透：客户端查询了根本不存在的数据，使得这个请求直达存储层，导致负载过大甚至宕机。原因：业务层误将缓存和库中的数据删除造成的，或者恶意攻击专门访问库中不存在的数据。解决：缓存空对象，布隆过滤器。
-

缓存击穿：一份热点数据，访问量非常大，缓存失效的瞬间，大量的请求直达存储层，导致服务崩溃。解决方案：永不过期，热点数据不设置过期时间。加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值
-
缓存雪崩：某一时刻缓存层无法提供服务，导致所有请求直达存储层，造成数据库宕机。可能是缓存中大量数据同时过期，也可能是redis节点发生故障，导致大量请求无法得到处理。解决：设置过期时间时附加一个随机数，避免大量的数据同时过期。构建高可用的redis服务，采用哨兵或集群模式，部署多个redis实例，这样即使个别宕机，依然可以保持服务整体可用。

## 高可用

高可用是通过设计，减少系统不能提供服务的时间，是分布式系统的基础也是保障系统可靠性的重要手段。Redis高可用的手段主要有四种：数据持久化、主从数据同步（主从复制）、Redis 哨兵模式（Sentinel）、Redis
集群（Cluster）。

- 数据持久化:保证了系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；
- 主从数据同步:可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换至另一台服务器以继续提供服务；
- 哨兵模式:用于发生故障之后自动切换服务器；
- Redis集群:除了可以提供主从和哨兵的功能之外，还提供了多个主从节点的集群功能，这样就可以把数据均匀的存储各个主机主节点上，实现了系统的横向扩展，大大提高了 Redis 的并发处理能力。
