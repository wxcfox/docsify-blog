## Redis基础

### 介绍

- 是什么
  - Redis是一个开源的、高性能的、基于***键值对***的NoSql数据库。

- 优点
  - Redis可以提供多种键值***数据类型***来满足多种应用场景的能力。数据类型有String、Hash、List、Set、Zset、Bitmap、HyperLogLog、GEO等数据结构。

  - Redis将数据放到内存中，且有着高性能的单线程模型，导致读写性能***快***。

  - Redis支持数据的***持久化***。可以将内存中的数据保存在磁盘中，重启后可以再次加载使用，有灾难恢复机制。内存用完之后也可以将不用的数据保存在磁盘中。

  - Redis***附加功能***多，提供了内存管理机制、发布订阅、事务、流水线、Lua脚本等多个附加功能。使用得当能大大增强系统性能和减少开发量。

- 应用场景
  - ***缓存***：redis访问速度块、支持的数据类型丰富,很适合用来做热点数据的缓存。
  - ***分布式锁***：通过Redis来做分布式锁是一种比较常见的方式。可以利用Redis的setnx命令，也可以基于Redisson实现分布式锁。
  - ***限流***：一般是通过Redis+Lua脚本的方式来实现限流。
  - ***消息队列***：Redis自带的list数据结构可以作为一个简单的队列使用。Redis5.0中增加的Stream类型的数据结构更适合用来做消息队列。它比较类似于Kafka，有主题和消费组的概念，支持消息持久化以及ACK机制。
  - ***其他***：通过Redis或Redis扩展提供的数据结构，可以很方便地完成复杂的业务场景。比如通过sorted set维护排行榜，通过expire实现限时器、通过bitmap 统计活跃用户。

### Redis VS Memcached

共同点：

- 都是基于内存的数据库，一般都用来做缓存。
- 都有过期策略。
- 性能都很高。

不同点：

- Redis数据类型更丰富。Memcached只支持简单的kv数据类型。
- Redis支持数据的持久化。可以将内存中的数据保存在磁盘中，重启后可以再次加载使用。有灾难恢复机制。内存用完之后也可以将不用的数据保存在磁盘中。Memcached把数据全部存在内容中，会在服务器内存用完之后会报错。
- Redis原生支持cluster集群，Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
- Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）
- Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 还支持更多的编程语言。
- Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

### 为什么用Redis做缓存

- 高性能

操作缓存就是直接操作内存，速度快。

- 高并发

单机Redis一般大概能支持数十万qps，Redis集群则更高。

- 高可用

数据持久化、主从数据同步、哨兵模式、Redis集群

## Redis数据结构

### 介绍

- String：String是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的base64编码或者解码或者图片的路径）、序列化后的对象。
  - 编码：SDS简单动态字符串（Simple Dynamic String），相比于C的原生字符串，Redis自己构建的SDS不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为O(1)（C字符串为O(N)），除此之外，Redis的SDS API是安全的，不会造成缓冲区溢出。
  - 应用：常规数据存储、计数、分布式锁
- Hash：Hash是一种键值对的集合，类似于关联数组。
  - 编码：ZipList、Hashtable。hash对象保存的键和值字符串长度都小于64字节且键值对数量小于512个时使用ziplist，其他时候使用Hashtable.
  - 应用：对象数据存储
- List：List是一个有序的字符串集合，允许重复元素。
  - 编码：ZipList、LinkedList、QuickList。元素数量小且长度小时使用ziplist，否则使用linkedlist，3.2版本之后一般用quicklist代替前两个。
  - 应用：信息流展示、消息队列
- Set：Set是一种无序的字符串集合，不允许重复元素。
  - 编码：Intset、Hashtable。集合对象保存的所有元素都是整数值且不超过512个时适用Intset，其他时候使用Hashtable。
    - Intset内部维护了一个数组，存储的时候是有序的，在查找数据的时候是通过二分法查找来实现的。增删时间复杂度O(N)，查时间复杂度O(logN)。
    - Hashtable就是普通的哈希表（key为set的值，value为null）。增删查时间复杂度O(1)。
  - 应用：数据不重复、求交并补
- Zset：Zset是一个有序的字符串集合，不允许重复元素，每个元素都关联一个分数。
  - 编码：ZipList、SkipList+dict。当元素数量小于128个且每个元素长度小于64字节时使用ziplist，其他时候使用skiplist。
    - ziplist结构是一种紧凑的、连续存储的数据结构，用于节省内存空间，适用于存储小规模的有序集合。每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。增删查时间复杂度O(N)。
    - skiplist作为zset的底层存储结构的时候，使用skiplist按序保存元素及分值，使用dict来保存元素和分值的映射关系。增删查时间复杂度O(logN)。
  - 应用：排序
- 其他：Bitmap、HyperLogLog、GEO、Stream。

| 数据结构   | 编码                         |
| -------- | ---------------------------- |
| String   | SDS                          |
| List     | ZipList、LinkedList、QuickList|
| Hash     | ZipList、Hashtable            |
| Set      | Intset、Hashtable             |
| Zset     | ZipList、SkipList+dict        |

### Zset VS Set

- 相同点：都是string类型元素的集合，集合不允许重复的成员。

- 不同点：
  - ***是否有序***：Zset有序集合是有序的而Set集合是无序的。Zset为每个元素关联了一个得分score，可以通过score为成员排序，成员不可以重复但score可以重复。
  - ***编码不同***：[详见](### 介绍)
    - Set编码：Intset或Hashtable。
    - Zset编码分为ziplist或skiplist+dict。

### Zset编码：为啥有dict和skiplist的组合形式

- 通过使用dict和skiplist的组合，Redis在zset的操作中能够同时兼顾快速的查找操作和范围操作。
- dict，键为成员，值为分值，用于支持O(1)复杂度的按成员取分值操作。
- skiplist，按分值排序成员，用于支持平均复杂度为O(logN)的按分值定位成员操作以及范围操作

### Zset编码：为啥用skiplist而不用二叉树、红黑树等其他数据结构

- 范围查找：跳表效率比红黑树高。在平衡树上，找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其他不超过大值的节点。如果不对平衡树进行一定的改造，中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
- 单个查找：查找单个key，skiplist和平衡数的时间复杂度都为O(logN)。但hash表在保持较低的hash值冲突的前提下，查找时间复杂度接近O(1)，性能更高。
- 插入删除：平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入删除只需要修改相邻节点的指针，操作简单快速。
- 算法实现：跳表实现比红黑树简单。

### Zset存储过程

以zadd的操作为例分析Zset的添加过程，过程如下：

- 解析参数得到每个元素及其对应的分值
- 查找key对应的zset是否存在，不存在则创建。
- 如果存储格式是ziplist，那么在执行添加的过程中我们需要区分元素存在和不存在两种情况，存在情况下先删除后添加；不存在情况下则添加并且需要考虑元素的长度是否超出限制或实际已有的元素个数是否超过最大限制进而决定是否转为skiplist对象。
- 如果存储格式是skiplist，那么在执行添加的过程中我们需要区分元素存在和不存在两种情况，存在的情况下先删除后添加，不存在情况下那么就直接添加，在skiplist当中添加完以后我们同时需要更新dict的对象。

## Redis持久化机制

### RDB 持久化

Redis 默认采用的持久化方式，Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis
主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

### AOF 持久化

与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了）。

## Redis线程模型

### Redis单线程模型

- Redis采用的是单线程+IO多路复用技术。
- 单线程指的是Redis中读写操作和网络IO使用的是由一个线程来完成，但其他操作还是由其他线程完成的，比如持久化操作。
- 单线程既可以简化数据结构和算法的实现，同时也可以消除线程切换和锁竞争带来的消耗。
- Redis中采用的IO多路复用技术实现了单线程下同时处理多个IO请求。

### Redis单线程模型为什么还这么快

- Redis 的大部分操作都在***内存***中完成，并且采用了***高效的数据结构***，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以避免了多线程之间的竞争，省去了***多线程切换***带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了***I/O 多路复用机制***处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis
  只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis
  线程处理多个 IO 流的效果。

### Redis 6.0 之后为什么引入多线程

Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

## Redis内存管理

### 过期删除策略

- 惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
- 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。Redis 采用的是 定期删除+惰性 删除。

### 内存淘汰策略

## Redis生产问题

### Redis常见三种缓存问题

- 缓存穿透：客户端查询了根本不存在的数据，使得这个请求直达存储层，导致负载过大甚至宕机。原因：业务层误将缓存和库中的数据删除造成的，或者恶意攻击专门访问库中不存在的数据。解决：缓存空对象，布隆过滤器。
- 缓存击穿：一份热点数据，访问量非常大，缓存失效的瞬间，大量的请求直达存储层，导致服务崩溃。解决方案：永不过期，热点数据不设置过期时间。加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值。
- 缓存雪崩：某一时刻缓存层无法提供服务，导致所有请求直达存储层，造成数据库宕机。可能是缓存中大量数据同时过期，也可能是redis节点发生故障，导致大量请求无法得到处理。解决：设置过期时间时附加一个随机数，避免大量的数据同时过期。构建高可用的redis服务，采用哨兵或集群模式，部署多个redis实例，这样即使个别宕机，依然可以保持服务整体可用。

## Redis 缓存一致性如何保证

### 高可用

高可用是通过设计，减少系统不能提供服务的时间，是分布式系统的基础也是保障系统可靠性的重要手段。Redis高可用的手段主要有四种：数据持久化、主从数据同步（主从复制）、Redis 哨兵模式（Sentinel）、Redis
集群（Cluster）。

- 数据持久化:保证了系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；
- 主从数据同步:可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换至另一台服务器以继续提供服务；
- 哨兵模式:用于发生故障之后自动切换服务器；
- Redis集群:除了可以提供主从和哨兵的功能之外，还提供了多个主从节点的集群功能，这样就可以把数据均匀的存储各个主机主节点上，实现了系统的横向扩展，大大提高了 Redis 的并发处理能力。

## Redis实现分布式锁

### 原因：

分布式系统下，不同的服务通常运行在独立的JVM进程上。如果多个JVM进程共享同一份资源的话，使用本地锁没办法实现资源的互斥访问，此时得用分布式锁。举例：秒杀商品超卖。

### 特性：

互斥：任意一个时刻，锁只能被一个线程持有； 高可用：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。 可重入：一个节点获取了锁之后，还可以再次获取锁。

### 分布式锁实现方式：

关系型数据库（例如：MySQL）、分布式数据库（例如：Redis）、分布式协调服务框架（例如：zookeeper）

### redis实现方式：

#### 如何实现互斥？

SETNX实现互斥，释放锁用DEL。

为了防止误释放锁，可以先get再删除，比如用Lua脚本通过key对应的的value唯一值是否相等来判断，用Lua是为了保证锁释放操作的原子性。

为了防止无法释放锁（释放锁的逻辑挂掉），导致共享资源无法被其他线程访问，得加过期时间。

加过期时间时得注意和加锁保持原子操作，否则依然可能导致无法释放锁。

加锁且加过期时间保持原子操作后。锁过期时间也是个问题：如果操作共享资源的时间大于过期时间，会出现锁提前过期的问题，导致分布式锁失效。如果锁的超时时间过长，又影响到性能。

考虑锁的优雅续期：Redisson分布式锁自带续期机制，它提供了一个专门用来监控和续期锁的Watch Dog（看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。

Watch Dog：默认情况下，每过10秒，看门狗就会执行续期操作，将锁的超时时间设置为30秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。

#### 如何实现可重入？

可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。

因此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于0时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。

Redisson分布式锁内置了可重入锁类型。

#### 如何实现高可用？

为了避免单点故障，生产环境下的redis服务通常是集群化部署的。Redis集群下，上面介绍到的分布式锁的实现会存在一些问题。由于Redis集群数据同步到各个节点时是异步的，如果在Redis主节点获取到锁后，在没有同步到其他节点时，Redis主节点宕机了，此时新的Redis主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。

Redlock算法：客户端向Redis集群中的多个独立的Redis实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，就算客户端成功地获得分布式锁，否则加锁失败。即使部分Redis节点出现问题，只要保证Redis集群中有半数以上的Redis节点可用，分布式锁服务就是正常的。Redlock是直接操作Redis节点的，并不是通过Redis集群操作的，这样才可以避免Redis集群主从切换导致的锁丢失问题。