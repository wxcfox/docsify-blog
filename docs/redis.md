## Redis基础

### 介绍

- ***是什么***
  - Redis是一个开源的、高性能的、基于***键值对***的NoSql数据库。

- ***优点***
  - Redis可以提供多种键值***数据类型***来满足多种应用场景的能力。数据类型有String、Hash、List、Set、Zset、Bitmap、HyperLogLog、GEO等数据结构。

  - Redis将数据放到内存中，且有着高性能的单线程模型，导致读写性能***快***。

  - Redis支持数据的***持久化***。可以将内存中的数据保存在磁盘中，重启后可以再次加载使用，有灾难恢复机制。内存用完之后也可以将不用的数据保存在磁盘中。

  - Redis***附加功能***多，提供了内存管理机制、发布订阅、事务、流水线、Lua脚本等多个附加功能。使用得当能大大增强系统性能和减少开发量。

- ***应用场景***
  - ***缓存***：redis访问速度块、支持的数据类型丰富,很适合用来做热点数据的缓存。
  - ***分布式锁***：通过Redis来做分布式锁是一种比较常见的方式。可以利用Redis的setnx命令，也可以基于Redisson实现分布式锁。
  - ***限流***：一般是通过Redis+Lua脚本的方式来实现限流。
  - ***消息队列***：Redis自带的list数据结构可以作为一个简单的队列使用。Redis5.0中增加的Stream类型的数据结构更适合用来做消息队列。它比较类似于Kafka，有主题和消费组的概念，支持消息持久化以及ACK机制。
  - ***其他***：通过Redis或Redis扩展提供的数据结构，可以很方便地完成复杂的业务场景。比如通过sorted set维护排行榜，通过expire实现限时器、通过bitmap 统计活跃用户。

### Redis VS Memcached

共同点：

- 都是基于内存的数据库，一般都用来做缓存。
- 都有过期策略。
- 性能都很高。

不同点：

- Redis数据类型更丰富。Memcached只支持简单的kv数据类型。
- Redis支持数据的持久化。可以将内存中的数据保存在磁盘中，重启后可以再次加载使用。有灾难恢复机制。内存用完之后也可以将不用的数据保存在磁盘中。Memcached把数据全部存在内容中，会在服务器内存用完之后会报错。
- Redis原生支持cluster集群，Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
- Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）
- Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 还支持更多的编程语言。
- Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

### 为什么用Redis做缓存

- 高性能

操作缓存就是直接操作内存，速度快。

- 高并发

单机Redis一般大概能支持数十万qps，Redis集群则更高。

- 高可用

数据持久化、主从数据同步、哨兵模式、Redis集群

## Redis数据结构

## 介绍

- String：编码为SDS（Simple Dynamic String）。String是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的base64编码或者解码或者图片的路径）、序列化后的对象。
  - 应用：常规数据存储、计数、分布式锁
- Hash：编码为Hash Table、ZipList。
  - 应用：对象数据存储
- List：编码为LinkedList/ZipList/QuickList。
  - 应用：信息流展示、消息队列
- Set：编码为ZipList、Intset。
  - 应用：数据不重复、求交并补
- Zset：编码为ZipList、SkipList。
  - 应用：排序
- 其他：Bitmap、HyperLogLog、GEO、Stream。

### Zset 和 set 比较

- ***相同点***：Redis有序集合和集合，都是string类型元素的集合，且不允许重复的成员。

- ***不同点***：
  - ***score***：zset每个元素都会关联一个double类型的分数，可通过分数为成员排序。成员唯一，但score却可以重复。
  - ***编码***：
    - set编码：inset或hashset。添加、删除、查找的复杂度都是O(1)。
    - zset编码分为ziplist或skiplist：当元素数量小于128个且每个元素长度小于64字节时使用ziplist，其他时候使用skiplist。当ziplist作为zset的底层存储结构时候，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。当skiplist作为zset的底层存储结构的时候，使用skiplist按序保存元素及分值，使用dict来保存元素和分值的映射关系。

- ***zset编码为啥是两种数据结构组合***：
  实际上单独使用Hashmap或skiplist也可以实现有序集合，Redis使用两种数据结构组合的原因是：如果我们单独使用Hashmap，虽然能以O(1)的时间复杂度 **查找成员分值**
  ，但是因为Hashmap是以无序的方式来保存集合元素，所以每次进行 **范围操作** 的时候都要进行排序；而如果单独使用skiplist，虽然能执行范围操作，但查找操作的复杂度却由O(1)变为了O(logN)
  。因此Redis使用了两种数据结构来共同实现有序集合。

## Redis持久化机制

### RDB 持久化

Redis 默认采用的持久化方式，Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis
主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

### AOF 持久化

与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了）。

## Redis线程模型

### Redis单线程模型

- Redis采用的是单线程+IO多路复用技术。
- 单线程指的是Redis中读写操作和网络IO使用的是由一个线程来完成，但其他操作还是由其他线程完成的，比如持久化操作。
- 单线程既可以简化数据结构和算法的实现，同时也可以消除线程切换和锁竞争带来的消耗。
- Redis中采用的IO多路复用技术实现了单线程下同时处理多个IO请求。

### Redis单线程模型为什么还这么快

- Redis 的大部分操作都在***内存***中完成，并且采用了***高效的数据结构***，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以避免了多线程之间的竞争，省去了***多线程切换***带来的时间和性能上的开销，而且也不会导致死锁问题。
- Redis 采用了***I/O 多路复用机制***处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis
  只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis
  线程处理多个 IO 流的效果。

### Redis 6.0 之后为什么引入多线程

Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

## Redis内存管理

### 过期删除策略

- 惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
- 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

定期删除对内存更加友好，惰性删除对 CPU 更加友好。Redis 采用的是 定期删除+惰性 删除。

### 内存淘汰策略

## Redis生产问题

### Redis常见三种缓存问题

- 缓存穿透：客户端查询了根本不存在的数据，使得这个请求直达存储层，导致负载过大甚至宕机。原因：业务层误将缓存和库中的数据删除造成的，或者恶意攻击专门访问库中不存在的数据。解决：缓存空对象，布隆过滤器。
- 缓存击穿：一份热点数据，访问量非常大，缓存失效的瞬间，大量的请求直达存储层，导致服务崩溃。解决方案：永不过期，热点数据不设置过期时间。加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值。
- 缓存雪崩：某一时刻缓存层无法提供服务，导致所有请求直达存储层，造成数据库宕机。可能是缓存中大量数据同时过期，也可能是redis节点发生故障，导致大量请求无法得到处理。解决：设置过期时间时附加一个随机数，避免大量的数据同时过期。构建高可用的redis服务，采用哨兵或集群模式，部署多个redis实例，这样即使个别宕机，依然可以保持服务整体可用。

### Redis 缓存一致性如何保证

## 高可用

高可用是通过设计，减少系统不能提供服务的时间，是分布式系统的基础也是保障系统可靠性的重要手段。Redis高可用的手段主要有四种：数据持久化、主从数据同步（主从复制）、Redis 哨兵模式（Sentinel）、Redis
集群（Cluster）。

- 数据持久化:保证了系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；
- 主从数据同步:可以将数据存储至多台服务器，这样当遇到一台服务器宕机之后，可以很快地切换至另一台服务器以继续提供服务；
- 哨兵模式:用于发生故障之后自动切换服务器；
- Redis集群:除了可以提供主从和哨兵的功能之外，还提供了多个主从节点的集群功能，这样就可以把数据均匀的存储各个主机主节点上，实现了系统的横向扩展，大大提高了 Redis 的并发处理能力。
